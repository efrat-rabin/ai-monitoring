#!/usr/bin/env python3
"""Generate GroundCover monitor YAML via Cursor AI from PR comment context and post as reply."""

import os
import re
import sys
from pathlib import Path

import requests
import yaml

# Add libs for CursorClient
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "libs"))
# Same dir for post_preview_comment helpers
sys.path.insert(0, str(Path(__file__).parent))

from cursor_client import CursorClient
from post_preview_comment import extract_issue_data_from_comment, get_root_comment
from prompts import MONITOR_YAML_GENERATION_PROMPT


def _build_issue_context(root_body: str, issue_data: dict) -> str:
    """Build a single context string from root comment body and ISSUE_DATA."""
    parts = []
    if issue_data:
        parts.append("Structured issue data:")
        for key in ("file", "line", "severity", "category", "method", "description", "recommendation", "patch", "impact"):
            val = issue_data.get(key)
            if val is not None and str(val).strip():
                parts.append(f"  {key}: {val}")
    # Visible body without hidden blocks (so we don't duplicate)
    visible = re.sub(r"<!-- ISSUE_DATA: .+? -->", "", root_body, flags=re.DOTALL)
    visible = re.sub(r"<!-- STATUS: \w+ -->", "", visible).strip()
    if visible:
        parts.append("\nComment body:\n" + visible)
    return "\n".join(parts) if parts else root_body


def _extract_yaml_from_response(response: str) -> str:
    """Extract YAML string from Cursor response (raw YAML or markdown fenced block)."""
    text = response.strip()
    # ```yaml ... ``` or ``` ... ```
    for pattern in (r"```yaml\s*\n(.*?)\n```", r"```\s*\n(.*?)\n```"):
        match = re.search(pattern, text, re.DOTALL)
        if match:
            return match.group(1).strip()
    return text


def _post_comment_with_yaml(
    github_token: str, repository: str, pr_number: int, comment_id: int, yaml_str: str, verbose: bool = False
) -> int:
    """Post a PR review comment with the given YAML in a collapsible block. Returns comment ID."""
    owner, repo = repository.split("/")
    comment_body = """## GroundCover monitor preview

<details>
<summary>View full YAML</summary>

```yaml
""" + yaml_str + """
```

</details>

---

**Reply with `/create-monitor` to create it in GroundCover.**

_Generated by AI automation ðŸ¤–_"""

    url = f"https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}/comments"
    headers = {
        "Authorization": f"Bearer {github_token}",
        "Accept": "application/vnd.github+json",
    }
    payload = {"body": comment_body, "in_reply_to": comment_id}
    resp = requests.post(url, headers=headers, json=payload)
    resp.raise_for_status()
    if verbose:
        print(f"[DEBUG] Posted comment ID: {resp.json().get('id')}")
    return resp.json().get("id")


def _post_error_comment(
    github_token: str, repository: str, pr_number: int, comment_id: int, message: str
) -> None:
    """Post a short error message as reply when generation or validation fails."""
    owner, repo = repository.split("/")
    body = "âš ï¸ **Monitor generation failed**\n\n" + message + "\n\n_AI automation ðŸ¤–_"
    url = f"https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}/comments"
    headers = {"Authorization": f"Bearer {github_token}", "Accept": "application/vnd.github+json"}
    requests.post(url, headers=headers, json={"body": body, "in_reply_to": comment_id}).raise_for_status()


def main() -> int:
    import argparse

    parser = argparse.ArgumentParser(description="Generate monitor YAML via Cursor and post to PR")
    parser.add_argument("--pr-number", type=int, required=True)
    parser.add_argument("--repository", type=str, required=True)
    parser.add_argument("--comment-id", type=str, required=True)
    args = parser.parse_args()

    verbose = os.getenv("ACTIONS_STEP_DEBUG", "false").lower() in ("true", "1")
    github_token = os.getenv("GITHUB_TOKEN")
    cursor_api_key = os.getenv("CURSOR_API_KEY")

    if not github_token:
        print("ERROR: GITHUB_TOKEN not set")
        return 1
    if not cursor_api_key:
        print("ERROR: CURSOR_API_KEY not set")
        return 1

    comment_id_int = int(args.comment_id)
    pr_number = args.pr_number
    repository = args.repository

    try:
        # 1. Get root comment and build context
        root_comment = get_root_comment(github_token, repository, comment_id_int, verbose=verbose)
        if not root_comment:
            _post_error_comment(
                github_token, repository, pr_number, comment_id_int,
                "Could not find the root comment in this thread.",
            )
            return 1
        root_body = root_comment.get("body", "")
        issue_data = extract_issue_data_from_comment(root_body, verbose=verbose)
        issue_context = _build_issue_context(root_body, issue_data)
        if verbose:
            print(f"[INFO] Issue context length: {len(issue_context)} chars")

        # 2. Call Cursor
        client = CursorClient(api_key=cursor_api_key)
        if not client.install_cursor_cli():
            raise RuntimeError("Failed to install Cursor CLI")
        if not client.verify_setup():
            raise RuntimeError("Cursor CLI setup verification failed")

        prompt = MONITOR_YAML_GENERATION_PROMPT.format(issue_context=issue_context)
        raw = client.send_message(prompt, verbose=verbose)

        # Response may be dict with 'result' or the string itself
        if isinstance(raw, dict) and "result" in raw:
            response_text = raw["result"]
            if not isinstance(response_text, str):
                response_text = str(response_text)
        elif isinstance(raw, str):
            response_text = raw
        else:
            response_text = str(raw)

        yaml_str = _extract_yaml_from_response(response_text)
        if not yaml_str.strip():
            _post_error_comment(
                github_token, repository, pr_number, comment_id_int,
                "Cursor returned no YAML content.",
            )
            return 1

        # 3. Validate and normalize
        try:
            monitor = yaml.safe_load(yaml_str)
        except yaml.YAMLError as e:
            _post_error_comment(
                github_token, repository, pr_number, comment_id_int,
                f"Invalid YAML from model: {e}",
            )
            return 1
        if not isinstance(monitor, dict):
            _post_error_comment(
                github_token, repository, pr_number, comment_id_int,
                "Generated content is not a YAML object.",
            )
            return 1
        for key in ("title", "display", "model"):
            if key not in monitor:
                _post_error_comment(
                    github_token, repository, pr_number, comment_id_int,
                    f"Generated YAML missing required key: {key}",
                )
                return 1

        yaml_str = yaml.dump(monitor, default_flow_style=False, sort_keys=False, allow_unicode=True)

        # 4. Post comment
        _post_comment_with_yaml(
            github_token, repository, pr_number, comment_id_int, yaml_str.strip(), verbose=verbose
        )
        print("âœ“ Monitor YAML generated and comment posted")
        return 0

    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        if verbose:
            import traceback
            traceback.print_exc()
        try:
            _post_error_comment(
                github_token, repository, pr_number, comment_id_int,
                str(e),
            )
        except Exception:
            pass
        return 1


if __name__ == "__main__":
    sys.exit(main())
